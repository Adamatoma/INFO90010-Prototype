{"ast":null,"code":"import React, { forwardRef, useRef, useEffect } from 'react';\nimport Portal from '@reach/portal';\nimport { useRect } from '@reach/rect';\nimport { useForkedRef, getOwnerDocument } from '@reach/utils';\nimport tabbable from 'tabbable';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\r\n * Popover\r\n */\n\n\nvar Popover = /*#__PURE__*/forwardRef(function Popover(props, ref) {\n  return React.createElement(Portal, null, React.createElement(PopoverImpl, Object.assign({\n    ref: ref\n  }, props)));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  Popover.displayName = \"Popover\";\n}\n/**\r\n * PopoverImpl\r\n *\r\n * Popover is conditionally rendered so we can't start measuring until it shows\r\n * up, so useRect needs to live down here not up in Popover\r\n */\n\n\nvar PopoverImpl = /*#__PURE__*/forwardRef(function PopoverImpl(_ref, forwardedRef) {\n  var targetRef = _ref.targetRef,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? positionDefault : _ref$position,\n      _ref$unstable_observa = _ref.unstable_observableRefs,\n      unstable_observableRefs = _ref$unstable_observa === void 0 ? [] : _ref$unstable_observa,\n      props = _objectWithoutPropertiesLoose(_ref, [\"targetRef\", \"position\", \"unstable_observableRefs\"]);\n\n  var popoverRef = useRef(null);\n  var popoverRect = useRect(popoverRef, !props.hidden);\n  var targetRect = useRect(targetRef, !props.hidden);\n  var ref = useForkedRef(popoverRef, forwardedRef);\n  useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n  return React.createElement(\"div\", Object.assign({\n    \"data-reach-popover\": \"\",\n    ref: ref\n  }, props, {\n    style: _extends({\n      position: \"absolute\"\n    }, getStyles.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs)), props.style)\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  PopoverImpl.displayName = \"PopoverImpl\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction getStyles(position, targetRect, popoverRect) {\n  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    unstable_observableRefs[_key - 3] = arguments[_key];\n  }\n\n  return popoverRect ? position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function (ref) {\n    return ref.current;\n  }))) : {\n    visibility: \"hidden\"\n  };\n}\n\nfunction getTopPosition(targetRect, popoverRect) {\n  var _getCollisions = getCollisions(targetRect, popoverRect),\n      directionUp = _getCollisions.directionUp;\n\n  return {\n    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + \"px\" : targetRect.top + targetRect.height + window.pageYOffset + \"px\"\n  };\n}\n\nvar positionDefault = function positionDefault(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions2 = getCollisions(targetRect, popoverRect),\n      directionRight = _getCollisions2.directionRight;\n\n  return _extends({\n    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + \"px\" : targetRect.left + window.pageXOffset + \"px\"\n  }, getTopPosition(targetRect, popoverRect));\n};\n\nvar positionRight = function positionRight(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions3 = getCollisions(targetRect, popoverRect),\n      directionLeft = _getCollisions3.directionLeft;\n\n  return _extends({\n    left: directionLeft ? targetRect.left + window.pageXOffset + \"px\" : targetRect.right - popoverRect.width + window.pageXOffset + \"px\"\n  }, getTopPosition(targetRect, popoverRect));\n};\n\nvar positionMatchWidth = function positionMatchWidth(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  return _extends({\n    width: targetRect.width,\n    left: targetRect.left\n  }, getTopPosition(targetRect, popoverRect));\n};\n\nfunction getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {\n  if (offsetLeft === void 0) {\n    offsetLeft = 0;\n  }\n\n  if (offsetBottom === void 0) {\n    offsetBottom = 0;\n  }\n\n  var collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0\n  };\n  var directionRight = collisions.right && !collisions.left;\n  var directionLeft = collisions.left && !collisions.right;\n  var directionUp = collisions.bottom && !collisions.top;\n  var directionDown = collisions.top && !collisions.bottom;\n  return {\n    directionRight: directionRight,\n    directionLeft: directionLeft,\n    directionUp: directionUp,\n    directionDown: directionDown\n  };\n} // Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\n\n\nfunction useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {\n  var ownerDocument = getOwnerDocument(triggerRef.current);\n\n  function handleKeyDown(event) {\n    if (event.key === \"Tab\" && popoverRef.current && tabbable(popoverRef.current).length === 0) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  useEffect(function () {\n    if (ownerDocument) {\n      ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n      return function () {\n        ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }\n\n    return; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    var elements = ownerDocument && tabbable(ownerDocument);\n    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;\n    var elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current && ownerDocument ? triggerRef.current === ownerDocument.activeElement : false;\n  }\n\n  function focusFirstPopoverTabbable(event) {\n    var elements = popoverRef.current && tabbable(popoverRef.current);\n\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    var inPopover = popoverRef.current && ownerDocument ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;\n\n    if (inPopover) {\n      var elements = popoverRef.current && tabbable(popoverRef.current);\n      return Boolean(elements && ownerDocument && elements[elements.length - 1] === ownerDocument.activeElement);\n    }\n\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event) {\n    var elementAfterTrigger = getElementAfterTrigger();\n\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event) {\n    if (!event.shiftKey) return;\n    var elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event) {\n    var elements = popoverRef.current && tabbable(popoverRef.current);\n    var last = elements && elements[elements.length - 1];\n\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event) {\n    var elements = popoverRef.current && tabbable(popoverRef.current);\n\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n\n    return false;\n  }\n\n  function focusTriggerRef(event) {\n    var _triggerRef$current;\n\n    event.preventDefault();\n    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.focus();\n  }\n\n  function tabbedToBrowserChrome(event) {\n    var elements = ownerDocument && popoverRef.current ? tabbable(ownerDocument).filter(function (element) {\n      return !popoverRef.current.contains(element);\n    }) : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return ownerDocument ? event.target === tabbable(ownerDocument)[0] : false;\n  }\n\n  var restoreTabIndexTuplés = [];\n\n  function disableTabbablesInPopover() {\n    var elements = popoverRef.current && tabbable(popoverRef.current);\n\n    if (elements) {\n      elements.forEach(function (element) {\n        restoreTabIndexTuplés.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument && ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument && ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplés.forEach(function (_ref2) {\n      var element = _ref2[0],\n          tabIndex = _ref2[1];\n      element.tabIndex = tabIndex;\n    });\n  }\n}\n\nexport default Popover;\nexport { getCollisions, positionDefault, positionMatchWidth, positionRight };","map":{"version":3,"sources":["../src/index.tsx"],"names":["Popover","forwardRef","React","ref","PopoverImpl","targetRef","position","positionDefault","unstable_observableRefs","props","popoverRef","useRef","popoverRect","useRect","targetRect","useForkedRef","useSimulateTabNavigationForReactTree","style","getStyles","visibility","directionUp","getCollisions","top","window","directionRight","left","getTopPosition","positionRight","directionLeft","positionMatchWidth","width","offsetLeft","offsetBottom","collisions","right","bottom","directionDown","ownerDocument","getOwnerDocument","triggerRef","event","tabbable","shiftTabbedFromElementAfterTrigger","focusLastTabbableInPopover","shiftTabbedOutOfPopover","focusTriggerRef","shiftTabbedToBrowserChrome","disableTabbablesInPopover","tabbedFromTriggerToPopover","focusFirstPopoverTabbable","tabbedOutOfPopover","focusTabbableAfterTrigger","tabbedToBrowserChrome","useEffect","elements","targetIndex","elementAfterTrigger","inPopover","Boolean","getElementAfterTrigger","last","restoreTabIndexTuplés","element","tabIndex"],"mappings":"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","sourcesContent":["/**\n * Welcome to @reach/popover!\n */\n\nimport React, { useRef, forwardRef, useEffect } from \"react\";\nimport Portal from \"@reach/portal\";\nimport { useRect, PRect } from \"@reach/rect\";\nimport { getOwnerDocument, useForkedRef } from \"@reach/utils\";\nimport tabbable from \"tabbable\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Popover\n */\nconst Popover = forwardRef<HTMLDivElement, PopoverProps>(function Popover(\n  props,\n  ref\n) {\n  return (\n    <Portal>\n      <PopoverImpl ref={ref} {...props} />\n    </Portal>\n  );\n});\n\nexport type PopoverProps = {\n  children: React.ReactNode;\n  targetRef: React.RefObject<HTMLElement>;\n  position?: Position;\n  /**\n   * Render the popover markup, but hide it – used by MenuButton so that it\n   * can have an `aria-controls` attribute even when its menu isn't open, and\n   * used inside `Popover` as a hint that we can tell `useRect` to stop\n   * observing for better performance.\n   */\n  hidden?: boolean;\n  /**\n   * Testing this API so we might accept additional nodes that apps can use to\n   * determine the position of the popover. One example where it may be useful\n   * is for positioning the popover of a listbox where the cursor rests on top\n   * of the selected option. Pretty sure this will change so don't use it\n   * anywehre in public yet!\n   */\n  unstable_observableRefs?: React.RefObject<PossibleNode>[];\n} & React.HTMLAttributes<HTMLDivElement>;\n\nif (__DEV__) {\n  Popover.displayName = \"Popover\";\n}\n\nexport default Popover;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * PopoverImpl\n *\n * Popover is conditionally rendered so we can't start measuring until it shows\n * up, so useRect needs to live down here not up in Popover\n */\nconst PopoverImpl = forwardRef<HTMLDivElement, PopoverProps>(\n  function PopoverImpl(\n    {\n      targetRef,\n      position = positionDefault,\n      unstable_observableRefs = [],\n      ...props\n    },\n    forwardedRef\n  ) {\n    const popoverRef = useRef<HTMLDivElement>(null);\n    const popoverRect = useRect(popoverRef, !props.hidden);\n    const targetRect = useRect(targetRef, !props.hidden);\n    const ref = useForkedRef(popoverRef, forwardedRef);\n\n    useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n\n    return (\n      <div\n        data-reach-popover=\"\"\n        ref={ref}\n        {...props}\n        style={{\n          position: \"absolute\",\n          ...getStyles(\n            position,\n            targetRect,\n            popoverRect,\n            ...unstable_observableRefs\n          ),\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  PopoverImpl.displayName = \"PopoverImpl\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction getStyles(\n  position: Position,\n  targetRect: PRect | null,\n  popoverRect: PRect | null,\n  ...unstable_observableRefs: React.RefObject<PossibleNode>[]\n): React.CSSProperties {\n  return popoverRect\n    ? position(\n        targetRect,\n        popoverRect,\n        ...unstable_observableRefs.map((ref) => ref.current)\n      )\n    : { visibility: \"hidden\" };\n}\n\nfunction getTopPosition(targetRect: PRect, popoverRect: PRect) {\n  const { directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    top: directionUp\n      ? `${targetRect.top - popoverRect.height + window.pageYOffset}px`\n      : `${targetRect.top + targetRect.height + window.pageYOffset}px`,\n  };\n}\n\nexport const positionDefault: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionRight } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionRight\n      ? `${targetRect.right - popoverRect.width + window.pageXOffset}px`\n      : `${targetRect.left + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport const positionRight: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionLeft } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionLeft\n      ? `${targetRect.left + window.pageXOffset}px`\n      : `${targetRect.right - popoverRect.width + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport const positionMatchWidth: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  return {\n    width: targetRect.width,\n    left: targetRect.left,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nexport function getCollisions(\n  targetRect: PRect,\n  popoverRect: PRect,\n  offsetLeft: number = 0,\n  offsetBottom: number = 0\n) {\n  const collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom:\n      window.innerHeight <\n      targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0,\n  };\n\n  const directionRight = collisions.right && !collisions.left;\n  const directionLeft = collisions.left && !collisions.right;\n  const directionUp = collisions.bottom && !collisions.top;\n  const directionDown = collisions.top && !collisions.bottom;\n\n  return { directionRight, directionLeft, directionUp, directionDown };\n}\n\n// Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\nfunction useSimulateTabNavigationForReactTree<\n  T extends HTMLElement = HTMLElement,\n  P extends HTMLElement = HTMLElement\n>(triggerRef: React.RefObject<T>, popoverRef: React.RefObject<P>) {\n  const ownerDocument = getOwnerDocument(triggerRef.current);\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (\n      event.key === \"Tab\" &&\n      popoverRef.current &&\n      tabbable(popoverRef.current).length === 0\n    ) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  useEffect(() => {\n    if (ownerDocument) {\n      ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n      return () => {\n        ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }\n    return;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    const elements = ownerDocument && tabbable(ownerDocument);\n    const targetIndex =\n      elements && triggerRef.current\n        ? elements.indexOf(triggerRef.current)\n        : -1;\n    const elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current &&\n      popoverRef.current.contains(elementAfterTrigger || null)\n      ? false\n      : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current && ownerDocument\n      ? triggerRef.current === ownerDocument.activeElement\n      : false;\n  }\n\n  function focusFirstPopoverTabbable(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    const inPopover =\n      popoverRef.current && ownerDocument\n        ? popoverRef.current.contains(ownerDocument.activeElement || null)\n        : false;\n    if (inPopover) {\n      const elements = popoverRef.current && tabbable(popoverRef.current);\n      return Boolean(\n        elements &&\n          ownerDocument &&\n          elements[elements.length - 1] === ownerDocument.activeElement\n      );\n    }\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event: KeyboardEvent) {\n    const elementAfterTrigger = getElementAfterTrigger();\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event: KeyboardEvent) {\n    if (!event.shiftKey) return;\n    const elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    const last = elements && elements[elements.length - 1];\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n    return false;\n  }\n\n  function focusTriggerRef(event: KeyboardEvent) {\n    event.preventDefault();\n    triggerRef.current?.focus();\n  }\n\n  function tabbedToBrowserChrome(event: KeyboardEvent) {\n    const elements =\n      ownerDocument && popoverRef.current\n        ? tabbable(ownerDocument).filter(\n            (element) => !popoverRef.current!.contains(element)\n          )\n        : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event: KeyboardEvent) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return ownerDocument ? event.target === tabbable(ownerDocument)[0] : false;\n  }\n\n  let restoreTabIndexTuplés: [HTMLElement, number][] = [];\n\n  function disableTabbablesInPopover() {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      elements.forEach((element) => {\n        restoreTabIndexTuplés.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument &&\n        ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument &&\n      ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplés.forEach(([element, tabIndex]) => {\n      element.tabIndex = tabIndex;\n    });\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\nexport type Position = (\n  targetRect?: PRect | null,\n  popoverRect?: PRect | null,\n  ...unstable_observableNodes: PossibleNode[]\n) => React.CSSProperties;\n\ntype PossibleNode = null | undefined | HTMLElement | SVGElement;\n"]},"metadata":{},"sourceType":"module"}