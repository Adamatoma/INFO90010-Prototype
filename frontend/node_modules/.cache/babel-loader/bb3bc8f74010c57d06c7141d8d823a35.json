{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n[\n/* 0 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(1);\n  /***/\n},\n/* 1 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _utils = __webpack_require__(2);\n\n  Object.defineProperty(exports, 'combineChunks', {\n    enumerable: true,\n    get: function get() {\n      return _utils.combineChunks;\n    }\n  });\n  Object.defineProperty(exports, 'fillInChunks', {\n    enumerable: true,\n    get: function get() {\n      return _utils.fillInChunks;\n    }\n  });\n  Object.defineProperty(exports, 'findAll', {\n    enumerable: true,\n    get: function get() {\n      return _utils.findAll;\n    }\n  });\n  Object.defineProperty(exports, 'findChunks', {\n    enumerable: true,\n    get: function get() {\n      return _utils.findChunks;\n    }\n  });\n  /***/\n},\n/* 2 */\n\n/***/\nfunction (module, exports) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\n   * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n   * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n   */\n\n  var findAll = exports.findAll = function findAll(_ref) {\n    var autoEscape = _ref.autoEscape,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$findChunks = _ref.findChunks,\n        findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,\n        sanitize = _ref.sanitize,\n        searchWords = _ref.searchWords,\n        textToHighlight = _ref.textToHighlight;\n    return fillInChunks({\n      chunksToHighlight: combineChunks({\n        chunks: findChunks({\n          autoEscape: autoEscape,\n          caseSensitive: caseSensitive,\n          sanitize: sanitize,\n          searchWords: searchWords,\n          textToHighlight: textToHighlight\n        })\n      }),\n      totalLength: textToHighlight ? textToHighlight.length : 0\n    });\n  };\n  /**\n   * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n   * @return {start:number, end:number}[]\n   */\n\n\n  var combineChunks = exports.combineChunks = function combineChunks(_ref2) {\n    var chunks = _ref2.chunks;\n    chunks = chunks.sort(function (first, second) {\n      return first.start - second.start;\n    }).reduce(function (processedChunks, nextChunk) {\n      // First chunk just goes straight in the array...\n      if (processedChunks.length === 0) {\n        return [nextChunk];\n      } else {\n        // ... subsequent chunks get checked to see if they overlap...\n        var prevChunk = processedChunks.pop();\n\n        if (nextChunk.start <= prevChunk.end) {\n          // It may be the case that prevChunk completely surrounds nextChunk, so take the\n          // largest of the end indeces.\n          var endIndex = Math.max(prevChunk.end, nextChunk.end);\n          processedChunks.push({\n            highlight: false,\n            start: prevChunk.start,\n            end: endIndex\n          });\n        } else {\n          processedChunks.push(prevChunk, nextChunk);\n        }\n\n        return processedChunks;\n      }\n    }, []);\n    return chunks;\n  };\n  /**\n   * Examine text for any matches.\n   * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n   * @return {start:number, end:number}[]\n   */\n\n\n  var defaultFindChunks = function defaultFindChunks(_ref3) {\n    var autoEscape = _ref3.autoEscape,\n        caseSensitive = _ref3.caseSensitive,\n        _ref3$sanitize = _ref3.sanitize,\n        sanitize = _ref3$sanitize === undefined ? defaultSanitize : _ref3$sanitize,\n        searchWords = _ref3.searchWords,\n        textToHighlight = _ref3.textToHighlight;\n    textToHighlight = sanitize(textToHighlight);\n    return searchWords.filter(function (searchWord) {\n      return searchWord;\n    }) // Remove empty words\n    .reduce(function (chunks, searchWord) {\n      searchWord = sanitize(searchWord);\n\n      if (autoEscape) {\n        searchWord = escapeRegExpFn(searchWord);\n      }\n\n      var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');\n      var match = void 0;\n\n      while (match = regex.exec(textToHighlight)) {\n        var _start = match.index;\n        var _end = regex.lastIndex; // We do not return zero-length matches\n\n        if (_end > _start) {\n          chunks.push({\n            highlight: false,\n            start: _start,\n            end: _end\n          });\n        } // Prevent browsers like Firefox from getting stuck in an infinite loop\n        // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n\n\n        if (match.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n      }\n\n      return chunks;\n    }, []);\n  }; // Allow the findChunks to be overridden in findAll,\n  // but for backwards compatibility we export as the old name\n\n\n  exports.findChunks = defaultFindChunks;\n  /**\n   * Given a set of chunks to highlight, create an additional set of chunks\n   * to represent the bits of text between the highlighted text.\n   * @param chunksToHighlight {start:number, end:number}[]\n   * @param totalLength number\n   * @return {start:number, end:number, highlight:boolean}[]\n   */\n\n  var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {\n    var chunksToHighlight = _ref4.chunksToHighlight,\n        totalLength = _ref4.totalLength;\n    var allChunks = [];\n\n    var append = function append(start, end, highlight) {\n      if (end - start > 0) {\n        allChunks.push({\n          start: start,\n          end: end,\n          highlight: highlight\n        });\n      }\n    };\n\n    if (chunksToHighlight.length === 0) {\n      append(0, totalLength, false);\n    } else {\n      var lastIndex = 0;\n      chunksToHighlight.forEach(function (chunk) {\n        append(lastIndex, chunk.start, false);\n        append(chunk.start, chunk.end, true);\n        lastIndex = chunk.end;\n      });\n      append(lastIndex, totalLength, false);\n    }\n\n    return allChunks;\n  };\n\n  function defaultSanitize(string) {\n    return string;\n  }\n\n  function escapeRegExpFn(string) {\n    return string.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n  /***/\n\n}\n/******/\n]);","map":{"version":3,"sources":["webpack:/webpack/bootstrap 2a95070affdf3c0054f1","webpack:///src/index.js","webpack:///src/utils.js"],"names":["combineChunks","fillInChunks","findAll","findChunks","autoEscape","caseSensitive","sanitize","searchWords","textToHighlight","chunksToHighlight","chunks","totalLength","first","second","processedChunks","prevChunk","nextChunk","endIndex","Math","highlight","start","end","defaultFindChunks","defaultSanitize","searchWord","escapeRegExpFn","regex","match","allChunks","append","lastIndex","chunk","string"],"mappings":"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","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2a95070affdf3c0054f1","// @flow\n\nexport { combineChunks, fillInChunks, findAll, findChunks } from './utils'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// @flow\n\nexport type Chunk = {|\n  highlight: boolean,\n  start: number,\n  end: number,\n|};\n\n/**\n * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n */\nexport const findAll = ({\n  autoEscape,\n  caseSensitive = false,\n  findChunks = defaultFindChunks,\n  sanitize,\n  searchWords,\n  textToHighlight\n}: {\n  autoEscape?: boolean,\n  caseSensitive?: boolean,\n  findChunks?: typeof defaultFindChunks,\n  sanitize?: typeof defaultSanitize,\n  searchWords: Array<string>,\n  textToHighlight: string,\n}): Array<Chunk> => (\n  fillInChunks({\n    chunksToHighlight: combineChunks({\n      chunks: findChunks({\n        autoEscape,\n        caseSensitive,\n        sanitize,\n        searchWords,\n        textToHighlight\n      })\n    }),\n    totalLength: textToHighlight ? textToHighlight.length : 0\n  })\n)\n\n/**\n * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n * @return {start:number, end:number}[]\n */\nexport const combineChunks = ({\n  chunks\n}: {\n  chunks: Array<Chunk>,\n}): Array<Chunk> => {\n  chunks = chunks\n    .sort((first, second) => first.start - second.start)\n    .reduce((processedChunks, nextChunk) => {\n      // First chunk just goes straight in the array...\n      if (processedChunks.length === 0) {\n        return [nextChunk]\n      } else {\n        // ... subsequent chunks get checked to see if they overlap...\n        const prevChunk = processedChunks.pop()\n        if (nextChunk.start <= prevChunk.end) {\n          // It may be the case that prevChunk completely surrounds nextChunk, so take the\n          // largest of the end indeces.\n          const endIndex = Math.max(prevChunk.end, nextChunk.end)\n          processedChunks.push({highlight: false, start: prevChunk.start, end: endIndex})\n        } else {\n          processedChunks.push(prevChunk, nextChunk)\n        }\n        return processedChunks\n      }\n    }, [])\n\n  return chunks\n}\n\n/**\n * Examine text for any matches.\n * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n * @return {start:number, end:number}[]\n */\nconst defaultFindChunks = ({\n  autoEscape,\n  caseSensitive,\n  sanitize = defaultSanitize,\n  searchWords,\n  textToHighlight\n}: {\n  autoEscape?: boolean,\n  caseSensitive?: boolean,\n  sanitize?: typeof defaultSanitize,\n  searchWords: Array<string>,\n  textToHighlight: string,\n}): Array<Chunk> => {\n  textToHighlight = sanitize(textToHighlight)\n\n  return searchWords\n    .filter(searchWord => searchWord) // Remove empty words\n    .reduce((chunks, searchWord) => {\n      searchWord = sanitize(searchWord)\n\n      if (autoEscape) {\n        searchWord = escapeRegExpFn(searchWord)\n      }\n\n      const regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi')\n\n      let match\n      while ((match = regex.exec(textToHighlight))) {\n        let start = match.index\n        let end = regex.lastIndex\n        // We do not return zero-length matches\n        if (end > start) {\n          chunks.push({highlight: false, start, end})\n        }\n\n        // Prevent browsers like Firefox from getting stuck in an infinite loop\n        // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n        if (match.index === regex.lastIndex) {\n          regex.lastIndex++\n        }\n      }\n\n      return chunks\n    }, [])\n}\n// Allow the findChunks to be overridden in findAll,\n// but for backwards compatibility we export as the old name\nexport {defaultFindChunks as findChunks}\n\n/**\n * Given a set of chunks to highlight, create an additional set of chunks\n * to represent the bits of text between the highlighted text.\n * @param chunksToHighlight {start:number, end:number}[]\n * @param totalLength number\n * @return {start:number, end:number, highlight:boolean}[]\n */\nexport const fillInChunks = ({\n  chunksToHighlight,\n  totalLength\n}: {\n  chunksToHighlight: Array<Chunk>,\n  totalLength: number,\n}): Array<Chunk> => {\n  const allChunks = []\n  const append = (start, end, highlight) => {\n    if (end - start > 0) {\n      allChunks.push({\n        start,\n        end,\n        highlight\n      })\n    }\n  }\n\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false)\n  } else {\n    let lastIndex = 0\n    chunksToHighlight.forEach((chunk) => {\n      append(lastIndex, chunk.start, false)\n      append(chunk.start, chunk.end, true)\n      lastIndex = chunk.end\n    })\n    append(lastIndex, totalLength, false)\n  }\n  return allChunks\n}\n\nfunction defaultSanitize (string: string): string {\n  return string\n}\n\nfunction escapeRegExpFn (string: string): string {\n  return string.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""},"metadata":{},"sourceType":"script"}