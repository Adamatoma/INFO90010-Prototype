{"ast":null,"code":"import { useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport observeRect from '@reach/observe-rect';\nimport { useIsomorphicLayoutEffect } from '@reach/utils';\n/**\r\n * Welcome to @reach/rect!\r\n *\r\n * Measures DOM elements (aka. bounding client rect).\r\n *\r\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\r\n * @see Docs                  https://reach.tech/rect\r\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\r\n */\n\n/**\r\n * Rect\r\n *\r\n * @param props\r\n */\n\nvar Rect = function Rect(_ref) {\n  var onChange = _ref.onChange,\n      _ref$observe = _ref.observe,\n      observe = _ref$observe === void 0 ? true : _ref$observe,\n      children = _ref.children;\n  var ref = useRef(null);\n  var rect = useRect(ref, observe, onChange);\n  return children({\n    ref: ref,\n    rect: rect\n  });\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * useRect\r\n *\r\n * @param nodeRef\r\n * @param observe\r\n * @param onChange\r\n */\n\n\nfunction useRect(nodeRef, observe, onChange) {\n  if (observe === void 0) {\n    observe = true;\n  }\n\n  var _useState = useState(nodeRef.current),\n      element = _useState[0],\n      setElement = _useState[1];\n\n  var initialRectIsSet = useRef(false);\n  var initialRefIsSet = useRef(false);\n\n  var _useState2 = useState(null),\n      rect = _useState2[0],\n      setRect = _useState2[1];\n\n  var onChangeRef = useRef();\n  useIsomorphicLayoutEffect(function () {\n    onChangeRef.current = onChange;\n\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n  useIsomorphicLayoutEffect(function () {\n    var observer;\n    var elem = element; // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn(\"You need to place the ref\");\n      }\n\n      return cleanup;\n    }\n\n    observer = observeRect(elem, function (rect) {\n      onChangeRef.current && onChangeRef.current(rect);\n      setRect(rect);\n    });\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element]);\n  return rect;\n}\n\nexport default Rect;\nexport { Rect, useRect };","map":{"version":3,"sources":["../src/index.tsx"],"names":["Rect","onChange","observe","children","ref","useRef","rect","useRect","PropTypes","func","nodeRef","element","setElement","useState","initialRectIsSet","initialRefIsSet","setRect","onChangeRef","useIsomorphicLayoutEffect","elem","console","observer","observeRect"],"mappings":"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","sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reach.tech/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport React, { useRef, useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nexport const Rect: React.FC<RectProps> = ({\n  onChange,\n  observe = true,\n  children,\n}) => {\n  const ref = useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, observe, onChange);\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reach.tech/rect#rect-props\n */\nexport type RectProps = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reach.tech/rect#rect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nexport function useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe: boolean = true,\n  onChange?: (rect: DOMRect) => void\n): null | DOMRect {\n  let [element, setElement] = useState(nodeRef.current);\n  let initialRectIsSet = useRef(false);\n  let initialRefIsSet = useRef(false);\n  let [rect, setRect] = useState<DOMRect | null>(null);\n  let onChangeRef = useRef<typeof onChange>();\n\n  useIsomorphicLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useIsomorphicLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      onChangeRef.current && onChangeRef.current(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element]);\n\n  return rect;\n}\n\nexport default Rect;\n\nexport type PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n"]},"metadata":{},"sourceType":"module"}