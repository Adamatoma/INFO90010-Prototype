{"ast":null,"code":"var props = [\"bottom\", \"height\", \"left\", \"right\", \"top\", \"width\"];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;","map":{"version":3,"sources":["../src/index.ts"],"names":["props","rectChanged","a","b","observedNodes","run","changedStates","newRect","node","state","cb","rafId","window","observeRect","observe","wasEmpty","rect","hasRectChanged","callbacks","unobserve","index","cancelAnimationFrame"],"mappings":"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","sourcesContent":["let props: (keyof DOMRect)[] = [\n\t\"bottom\",\n\t\"height\",\n\t\"left\",\n\t\"right\",\n\t\"top\",\n\t\"width\",\n];\n\nlet rectChanged = (a: DOMRect = {} as DOMRect, b: DOMRect = {} as DOMRect) =>\n\tprops.some((prop) => a[prop] !== b[prop]);\n\nlet observedNodes = new Map<Element, RectProps>();\nlet rafId: number;\n\nlet run = () => {\n\tconst changedStates: RectProps[] = [];\n\tobservedNodes.forEach((state, node) => {\n\t\tlet newRect = node.getBoundingClientRect();\n\t\tif (rectChanged(newRect, state.rect)) {\n\t\t\tstate.rect = newRect;\n\t\t\tchangedStates.push(state);\n\t\t}\n\t});\n\n\tchangedStates.forEach((state) => {\n\t\tstate.callbacks.forEach((cb) => cb(state.rect));\n\t});\n\n\trafId = window.requestAnimationFrame(run);\n};\n\nexport default function observeRect(\n\tnode: Element,\n\tcb: (rect: DOMRect) => void\n) {\n\treturn {\n\t\tobserve() {\n\t\t\tlet wasEmpty = observedNodes.size === 0;\n\t\t\tif (observedNodes.has(node)) {\n\t\t\t\tobservedNodes.get(node)!.callbacks.push(cb);\n\t\t\t} else {\n\t\t\t\tobservedNodes.set(node, {\n\t\t\t\t\trect: undefined,\n\t\t\t\t\thasRectChanged: false,\n\t\t\t\t\tcallbacks: [cb],\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (wasEmpty) run();\n\t\t},\n\n\t\tunobserve() {\n\t\t\tlet state = observedNodes.get(node);\n\t\t\tif (state) {\n\t\t\t\t// Remove the callback\n\t\t\t\tconst index = state.callbacks.indexOf(cb);\n\t\t\t\tif (index >= 0) state.callbacks.splice(index, 1);\n\n\t\t\t\t// Remove the node reference\n\t\t\t\tif (!state.callbacks.length) observedNodes.delete(node);\n\n\t\t\t\t// Stop the loop\n\t\t\t\tif (!observedNodes.size) cancelAnimationFrame(rafId);\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport type PartialRect = Partial<DOMRect>;\n\nexport type RectProps = {\n\trect: DOMRect | undefined;\n\thasRectChanged: boolean;\n\tcallbacks: Function[];\n};\n"]},"metadata":{},"sourceType":"module"}